# alpaka

>APK diff tool

Alpaka is an APK diff tool written in Python 3.

It mainly uses [androguard](https://github.com/androguard) to analyze two apks (usually different versions of the same app), then it indicates any modification that was done between them.

The tool is still in development

#### Obfuscated Apks
Alpaka was built to work even if the APK is obfuscated.
It's up for the user to configure how the obfuscation detectors will work or use the default ones.

## Setup
Alpaka is not yet a Python package but it should be!

Right now in order to use the tool all you need to clone and install the requirements:

`pip3 install -r requirements.txt`

##### Known Errors
- The `simhash-py` package might be problematic if you have a package named `simhash` installed.
If you do have it you should `pip3 uninstall simhash` first.

## Usage
Alpaka contains 2 main executables:

#### Alpaka match
alpaka_match.py

This executable is used to match classes from the 2 apks.
It takes 2 apk files as input and outputs a matches file in json format.

######Additional parameters
| Parameter              | Description                                                                               |
| ---------              | -----------                                                                               |
| --no-package-matching  | Disables matching the classes based on their containing package. Increases runtime.       |
| --no-name-matching     | Disables matching classes by name if the names are unobfuscated. Increases runtime.       |
| --class-filter         | Used to specify a class filter, which filters out irrelevant classes to decrease runtime. |
| --obfuscation-detector | Used to specify a custom obfuscation detector.                                            |
| --weights-file         | Used to specify custom distance calculation weights. For advanced users.                  |
More information on class filters, obfuscation detectors and distance calculation weights is avalilable [here](#custom-filters-obfuscation-detectors-and-weights)

#### Alpaka diff
alpaka_diff.py

This executable is used to display file diffs from 2 source directories based on a matches file generated by [Alpaka match](#alpaka-match).

It supports using either smali or java source files, with support for jadx decompiled sources (with the AnonymousClass prefix).

###### Notes:
- The source directories must be specified in the same order as their corresponding apks were specified to alpaka match
- Alpaka currently supports only lookup by classes from apk 1.
- The directories given to alpaka diff must contain directly the sources.
- Alpaka diff currently does not support inner classes in original java syntax.
  Only classes in separate files are supported (OuterClass$InnerClass.java)

#### Custom Filters, Obfuscation Detectors and weights
Alpaka match allows specifying custom filters, obfuscation detectors and weights to allow better results and/or performance for your specific apks

##### Filters
Filters are used to limit the classes being matched to a specific set to improve performance.

A filter can be specified by giving alpaka match a python module containing a function named `external_filter`, which accepts 2 parameters: full class name (smali format) and [class info](#the-classinfo-type) .

Example:
```python
from alpaka.apk.class_info import ClassInfo

def a_dank_filter(class_name: str, class_info: ClassInfo):
    return 'meme' in class_name

external_filter = a_dank_filter
```

##### Obfuscation Detectors
Obfuscation detectors are objects that can determine whether a class or a package's name is obfuscated.
Obfuscation detection is used in various ways in the alpaka application. Generally, **low false negatives are more important than low false positives**.

An obfuscation detector can be specified by giving alpaka match a python module containing a class named `ExternalObfuscationDetector`, implementing the interface `ObfuscationDetector`.
```python
# file: alpaka.obfuscation_detection.base

class ObfuscationDetector(abc.ABC):

    def is_class_name_obfuscated(self, class_name: str) -> bool:
        raise NotImplementedError()

    def is_package_name_obfuscated(self, package_name: str) -> bool:
        raise NotImplementedError()
```
Additionally, you can use the decorator `MemoizingObfuscationDetector` (`alpaka.obfuscation_detection.memoization`) to
add memoization functionality to your obfuscation detector and possibly increase performance.

Example:
```python
from alpaka.obfuscation_detection.base import ObfuscationDetector
from alpaka.obfuscation_detection.memoization import MemoizingObfuscationDetector

@MemoizingObfuscationDetector
class OptimisticObfuscationDetector(ObfuscationDetector):

    def is_class_name_obfuscated(self, class_name: str) -> bool:
        return False  # believe in people!

    def is_package_name_obfuscated(self, package_name: str) -> bool:
        return False

ExternalObfuscationDetector = OptimisticObfuscationDetector
```

##### Weights
The class distance calculation process is done by comparing multiple signature parameters,
and combining the results with different weights for each parameter.
The default weights can be overridden by giving a json file of the following format:
```json
{
  "member_count": 0.0,
  "method_count": 0.0,
  "instructions_count": 0.0,
  "members_simhash": 0.0,
  "methods_params_simhash": 0.0,
  "methods_returns_simhash": 0.0,
  "instructions_simhash": 0.0,
  "instruction_shingles_simhash": 0.0,
  "implemented_interfaces_count": 0.0,
  "implemented_interfaces_simhash": 0.0,
  "superclass_hash": 0.0,
  "string_literals_count": 0.0,
  "string_literals_simhash": 0.0
}
```
**This feature is only recommended for advanced users!**

##### The ClassInfo Type
This type represents classes from the apk analyzed and compared by alpkaka.
Class filter functions accepts parameters of this type.
The ClassInfo type exposes the following interface:
```python
class ClassInfo:
    analysis: ClassAnalysis  # from androguard
    is_obfuscated_name: bool
    signature: ClassSignature
```

## Technical overview

Analyzing an APK is easily done by androguard. Alpaka's part is detecting the modifications that were done between the apks.
##### Challenges

- The names and offsets of packages, classes, functions and variables inside the apk can be changed (either by obfuscation or manually by the developer).
    - Thus, in order to detect the modifications that were done on a given class, we first have to find the matching class in the other apk.
    - Furthermore, matching between classes must be done by detecting structural similarities; this method can yield false answers.
- Modern Apks can be pretty big, as a result the diff process must be efficient in memory and computation time.


To overcome the challenges above, alpaka's diff process is constructed from 3 stages:

#### Stage 1: Filtering Classes (Optional)
Finding a class match in a `100,000` classes list can consume a lot of resources, and will probably yield a false answer.
Hence, filtering irrelevant classes from the known classes is very useful and efficient.

- It is always recommended to filter native Java and Android classes.
- The user chooses which classes to filter

#### Stage 2: Matching Classes Pools (Optional)
Looking for a class match is a heavy O(number_of_classes^2) computation, even if the number of classes was reduced by a filter.

It is better to divide the classes in both apks to groups (called pools) that we can easily match.

After dividing the classes into pools, the class matching stage can search for a match in a smaller and targeted group, which will be more efficient and accurate.

##### Dividing To Pools By Packages
Right now the only way to divide to pools is by packages.

Packing the apk will group classes from the same Java package into a package object.
Then package objects can be used as pools and easily matched by name.

Notes:
- In case the package name was indicated as obfuscated by an ObfuscationDetector, it will not be matched. 
- Alpaka lets the user decide whether he wants to pack the APK or not.

### Stage 3: Matching Classes
Matching is done in two steps:
1. Matching by class name (if it's not obfuscated)
2. If the above step did not yield results - matching by class signature.

A class signature is made from structural properties, such as:
- number of methods
- methods return types
- methods parameters types
- number of fields
- class instructions
- ... etc ...

The similarity between classes is determined by the distance between their signatures.

##### How Does a Class Signature Work:
While properties like number of methods can be easily represented and differentiated, other properties, like methods return types and class instructions, are more complex.

Most of the complex properties are represented by a Simhash.
Unlike other hashes, Simhash is one where similar items are hashed to similar hash values.

## Tests
Some of the tests require large APKs (Facebook, WhatsApp, etc.). These APKs are not included in the default branch.

if you want to test them you should copy them from the '**tests/add_large_apks**' branch.